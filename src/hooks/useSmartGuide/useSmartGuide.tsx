import { useRef, useEffect, useCallback } from 'react';
import { OnDrag, OnDragGroup, OnResize, OnResizeGroup } from 'react-moveable';
import SmartGuideHelper from '../../modules/Editor/components/BoundingBox/SmartGuideHelper';
import {
  Snap,
  SmartGuideConfig,
  computeType,
  matchType,
  SetSmartGuideConfig,
  matchDragParamsType,
  matchResizeParamsType,
  Compute,
  Match,
  Hide,
  FrameValue,
  pageScroll,
} from '../../modules/Editor/components/BoundingBox/BoundingBox.types';
import { SnapRect } from './useSmartGuide.types';
import { DEFAULT_SNAP_DATA } from './useSmartGuide.config';
import {
  getCenterDOMRect,
  getRoundedDomRect,
  getWidgetRectFromStyle,
  getAxis,
  getRotatedRectByAngle,
  parseAngle,
  getResizedWidgetRect,
  calculateBeforeTranslate,
} from './useSmartGuide.helpers';
import { useFlowCoreValue } from 'modules/Editor/components/FlowCore';

/**
 * Type guard to distinguish event types
 */
function checkDrag(e: matchType, type: string): e is OnDrag | OnDragGroup {
  return type === 'drag';
}
function checkResize(e: matchType, type: string): e is OnResize | OnResizeGroup {
  return type === 'resize';
}

/**
 * This is the hooks for using SmartGuideHelper lib.
 * compute, match, hide are called on each event and do the following:
 *   - compute: Generate the map for the currently rendered widget on the canvas. Since the key is generated as a number, it helps to quickly find the target using binary search.
 *   - match: Find targets close to the computed value then calls snap() to render the indicator follow the found target.
 *   - hide: Removes all currently rendered indicators generated by snap().
 *
 * Note:
 * 1. The translate value of OnDragGroup is returned without zoomLevel calculated.
 * Since we do not know for sure whether it is intended or a bug in the existing library, we add an additional zoomLevel calculation by checking isGroup in the useSmartGuide code.
 *
 * 2. it uses the e.beforeTranslate instead of the e.translate
 * e.translate is calculated using the matrix and all transform, unnecessary values ​​are returned with some changes(e.g. rotating, resizing or etc)
 * Ref: https://github.com/daybrush/moveable/blob/master/packages/react-moveable/src/react-moveable/ables/Draggable.tsx#L193-L194
 *
 * @param element
 * @param smartGuideConfig
 * @returns
 */
export function useSmartGuide(
  element: HTMLElement | undefined,
  smartGuideConfig: SmartGuideConfig,
): [SetSmartGuideConfig, Compute, Match, Hide] {
  const smartGuide = useRef<SmartGuideHelper | undefined>();
  const originBoundingBoxRect = useRef<DOMRect | undefined>();
  const originWidgetRect = useRef<SnapRect>(); // unrotated widget position
  const eventType = useRef('');
  const connectedLineElements = useFlowCoreValue('connectedLineElements');

  useEffect(() => {
    if (smartGuide.current || !element) return;
    smartGuide.current = new SmartGuideHelper(element, smartGuideConfig);
  }, [element, smartGuideConfig]);

  const setSmartGuideConfig = useCallback(
    (config: SmartGuideConfig) => {
      if (!smartGuide?.current?.setOptions) return;

      smartGuide.current.setOptions(config);
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [smartGuide?.current?.setOptions],
  );

  const compute = (e: computeType, type: string): void => {
    if (!smartGuide.current) return;

    // Set the type
    eventType.current = type;

    const isGroup = 'targets' in e;

    // To use only the center position as a target, reset top and left to the middle value, and change the width / height to 0.
    originBoundingBoxRect.current = smartGuideConfig?.useCenter
      ? getCenterDOMRect(e.target.getBoundingClientRect())
      : e.target.getBoundingClientRect();
    const roundedBoundingBoxRect = getRoundedDomRect(originBoundingBoxRect.current); // Round the Rect value for accuracy when using smartGuideHelper
    const originUI = {
      position: {
        top: roundedBoundingBoxRect.top,
        left: roundedBoundingBoxRect.left,
      },
    };
    originWidgetRect.current = getWidgetRectFromStyle(e.target as HTMLElement);

    let ignoreTargets = isGroup ? e.targets : [e.target];

    // Ignore connected line widgets
    ignoreTargets.forEach((element) => {
      const widgetId = element.id;
      const connectedLineElementList = connectedLineElements?.[widgetId];
      if (connectedLineElementList && connectedLineElementList.length > 0) {
        ignoreTargets = ignoreTargets.concat(connectedLineElementList);
      }
    });

    smartGuide.current.compute(roundedBoundingBoxRect, originUI, type, ignoreTargets);
  };

  const matchResize = (e: OnResize | OnResizeGroup, frame: FrameValue): Snap => {
    if (!smartGuide.current || !originBoundingBoxRect.current) return DEFAULT_SNAP_DATA;

    const zoomLevel = smartGuide.current.getOption('zoom') / 100;
    const degrees = parseAngle(frame.rotate);
    frame.rotate = degrees; // convert frame.rotate to the range of [0, 360)
    const axis = getAxis(e.direction, frame.rotate);
    const newWidgetRect = getResizedWidgetRect(originWidgetRect.current as SnapRect, e.direction, e.dist);

    /**
     * Return the beforeTranslate value same as breforeTranslate given in onResize event
     */
    const beforeTranslate = calculateBeforeTranslate(
      originWidgetRect.current as SnapRect,
      newWidgetRect,
      degrees,
      e.direction,
      e.dist,
    );

    const rotatedMovingRect = getRotatedRectByAngle(newWidgetRect, degrees);
    const rotatedOriginRect = getRotatedRectByAngle(originWidgetRect.current as SnapRect, degrees);

    // Calculate offsets of the rotation widget to use in the current bounding box
    const translateX = rotatedMovingRect.leftPx - rotatedOriginRect.leftPx;
    const translateY = rotatedMovingRect.topPx - rotatedOriginRect.topPx;
    const translateWidth = rotatedMovingRect.widthPx - rotatedOriginRect.widthPx;
    const translateHeight = rotatedMovingRect.heightPx - rotatedOriginRect.heightPx;

    const newUI = {
      position: {
        top: originBoundingBoxRect.current.top + translateY * zoomLevel,
        left: originBoundingBoxRect.current.left + translateX * zoomLevel,
      },
      size: {
        width: originBoundingBoxRect.current.width / zoomLevel + translateWidth,
        height: originBoundingBoxRect.current.height / zoomLevel + translateHeight,
      },
      axis,
    };
    const parsedNewUI = {
      ...newUI,
      position: {
        top: Math.round(newUI.position.top),
        left: Math.round(newUI.position.left),
      },
      size: {
        width: Math.round(newUI.size.width),
        height: Math.round(newUI.size.height),
      },
    };

    const result = {
      x: beforeTranslate[0],
      y: beforeTranslate[1],
      width: newUI.size.width,
      height: newUI.size.height,
    };

    /**
     * Calculate the widget data width and height using bounding box size and degrees
     * Returns the width and height of the rotated rectangle inside the bounding box
     *
     * W: width of the bounding box rect
     * H: height of the bounding box rect
     * w: width of the inner rect
     * h: height of the inner rect
     * t: radians of the inner rect
     *
     * w = (Wcos(t)-Hsin(t))/(cos(t)^2-sin(t)^2)
     * h = (Hcos(t)-Wsin(t))/(cos(t)^2-sin(t)^2)
     * when abs(t) = 45, 135, 225 .., the dividend and divisor become 0, directly take newWidgetRect.widthPx and heightPx as result.width and height
     */
    const innerRectRadians = (Math.abs(degrees % 90) * Math.PI) / 180;
    const is45DegRotation = degrees % 45 === 0 && (degrees / 45) % 2 === 1;

    const resultW = degrees % 180 < 90 ? result.width : result.height; // / zoomLevel;
    const resultH = degrees % 180 < 90 ? result.height : result.width; // / zoomLevel;
    result.width = is45DegRotation
      ? newWidgetRect.widthPx
      : (resultW * Math.cos(innerRectRadians) - resultH * Math.sin(innerRectRadians)) /
        (Math.cos(innerRectRadians) ** 2 - Math.sin(innerRectRadians) ** 2);
    result.height = is45DegRotation
      ? newWidgetRect.heightPx
      : (resultH * Math.cos(innerRectRadians) - resultW * Math.sin(innerRectRadians)) /
        (Math.cos(innerRectRadians) ** 2 - Math.sin(innerRectRadians) ** 2);

    /**
     * Snap feature
     */
    const isRotated = degrees !== 0;
    const isKeyboardMove = !e.inputEvent;
    const enableSnap = !isKeyboardMove && !isRotated;
    if (enableSnap) {
      smartGuide.current.match(e.target, parsedNewUI);
      const newPosition = smartGuide.current.snap(e, parsedNewUI);

      if ((newPosition.top ?? newPosition.left ?? newPosition.width ?? newPosition.height) !== null) {
        const canvasOffsetX = smartGuide.current.getPageOffset().left;
        const canvasOffsetY = smartGuide.current.getPageOffset().top;
        const newUIRect = {
          x: newPosition.left !== null ? newPosition.left : newUI.position.left,
          y: newPosition.top !== null ? newPosition.top : newUI.position.top,
          width: newPosition.width !== null ? newPosition.width : newUI.size.width,
          height: newPosition.height !== null ? newPosition.height : newUI.size.height,
        };

        // side handler
        if (axis.length === 1) {
          if (newPosition.left !== null) {
            newUIRect.x = newPosition.left - canvasOffsetX;
            const diffX = newUIRect.x - (newUI.position.left - canvasOffsetX);
            result.x = result.x + diffX / zoomLevel;
          }
          if (newPosition.top !== null) {
            newUIRect.y = newPosition.top - canvasOffsetY;
            const diffY = newUIRect.y - (newUI.position.top - canvasOffsetY);
            result.y = result.y + diffY / zoomLevel;
          }
        } else {
          // corner handler
          if (newPosition.width !== null) {
            const ratio = newPosition.width / originBoundingBoxRect.current.width;
            const newHeight = originBoundingBoxRect.current.height * ratio;

            if (axis.indexOf('n') !== -1) {
              const distanceY = newHeight - newUIRect.height;
              result.y = result.y - distanceY;
            }

            if (axis.indexOf('w') !== -1) {
              const distanceX = newPosition.width - newUI.size.width;
              result.x = result.x - distanceX;
            }

            newUIRect.height = newHeight;
          } else if (newPosition.height !== null) {
            const ratio = newPosition.height / originBoundingBoxRect.current.height;
            const newWidth = originBoundingBoxRect.current.width * ratio;

            if (axis.indexOf('n') !== -1) {
              const distanceY = newPosition.height - newUI.size.height;
              result.y = result.y - distanceY;
            }

            if (axis.indexOf('w') !== -1) {
              const distanceX = newWidth - newUIRect.width;
              result.x = result.x - distanceX;
            }

            newUIRect.width = newWidth;
          }
        }

        // Calculate the new widget's width and height by the bounding box size
        let resultWTemp = degrees % 180 < 90 ? newUIRect.width : newUIRect.height;
        let resultHTemp = degrees % 180 < 90 ? newUIRect.height : newUIRect.width;

        let resultSnapWidth =
          (resultWTemp * Math.cos(innerRectRadians) - resultHTemp * Math.sin(innerRectRadians)) /
          (Math.cos(innerRectRadians) ** 2 - Math.sin(innerRectRadians) ** 2);
        let resultSnapHeight =
          (resultHTemp * Math.cos(innerRectRadians) - resultWTemp * Math.sin(innerRectRadians)) /
          (Math.cos(innerRectRadians) ** 2 - Math.sin(innerRectRadians) ** 2);

        result.width = resultSnapWidth;
        result.height = resultSnapHeight;
      }
    }

    return result;
  };

  const matchDrag = (e: OnDrag | OnDragGroup, pageScrollAdjustment: pageScroll): Snap => {
    if (!smartGuide.current || !originBoundingBoxRect.current) return DEFAULT_SNAP_DATA;

    const isGroup = 'targets' in e;
    const zoomLevel = smartGuide.current.getOption('zoom') / 100;

    // pageScrollAdjustment[0] tracks scrollX of pageScrollContainer and pageScrollAdjustment[1] tracks scrollY of pageScrollContainer
    const targetSnapRect = {
      top:
        originBoundingBoxRect.current.top +
        (isGroup ? e.top : e.beforeTranslate[1] * zoomLevel) +
        pageScrollAdjustment[1],
      left:
        originBoundingBoxRect.current.left +
        (isGroup ? e.left : e.beforeTranslate[0] * zoomLevel) +
        pageScrollAdjustment[0],
    };

    const newUI = {
      position: {
        top: targetSnapRect.top,
        left: targetSnapRect.left,
      },
    };

    const targetRect = smartGuideConfig?.useCenter
      ? getCenterDOMRect(e.target.getBoundingClientRect())
      : e.target.getBoundingClientRect();

    smartGuide.current.match(targetRect, newUI);
    const newPosition = smartGuide.current.snap(e, newUI);
    const isKeyboardMove = !e.inputEvent;
    const enableSnap = isKeyboardMove
      ? false
      : Object.entries(newPosition).some((x) => !isNaN(Number.parseFloat(x[1] as string)));

    let snapX = null;
    let snapY = null;

    if (enableSnap) {
      const diffTop =
        !isNaN(Number.parseFloat(newPosition?.top)) && !isNaN(Number.parseFloat(newUI?.position.top.toString()))
          ? newPosition.top - newUI.position.top
          : null;
      const diffLeft =
        !isNaN(Number.parseFloat(newPosition?.left)) && !isNaN(Number.parseFloat(newUI?.position.left.toString()))
          ? newPosition.left - newUI.position.left
          : null;

      if (diffTop) {
        if (isGroup) {
          snapY = (e.top + diffTop + pageScrollAdjustment[1]) / zoomLevel;
        } else {
          snapY = e.beforeTranslate[1] + (diffTop + pageScrollAdjustment[1]) / zoomLevel;
        }
      }
      if (diffLeft) {
        if (isGroup) {
          snapX = (e.left + diffLeft + pageScrollAdjustment[0]) / zoomLevel;
        } else {
          snapX = e.beforeTranslate[0] + (diffLeft + pageScrollAdjustment[0]) / zoomLevel;
        }
      }
    }

    return {
      ...DEFAULT_SNAP_DATA,
      x: snapX,
      y: snapY,
    };
  };

  const match = (params: matchDragParamsType | matchResizeParamsType): Snap => {
    const { e } = params;
    const isDrag = checkDrag(e, eventType.current);
    const isResize = checkResize(e, eventType.current);
    let result = DEFAULT_SNAP_DATA as Snap;
    if (isDrag) {
      const { pageScrollAdjustment = [0, 0] } = params as matchDragParamsType;
      result = matchDrag(e, pageScrollAdjustment);
    } else if (isResize) {
      const { frame } = params as matchResizeParamsType;
      if (frame) result = matchResize(e, frame);
    }

    return result;
  };

  const hide = (): void => {
    if (!smartGuide.current) return;

    smartGuide.current.hide();
  };

  return [setSmartGuideConfig, compute, match, hide];
}
